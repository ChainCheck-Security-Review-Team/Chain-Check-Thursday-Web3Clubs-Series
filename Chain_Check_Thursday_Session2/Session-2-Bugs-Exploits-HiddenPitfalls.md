# Common Bugs, Exploits and Hidden Pitfalls (PT1)
## 1. Reentrancy

### 1.1 What it is
Reentrancy occurs when a contract makes an external call to another untrusted contract before it has finalized internal state changes. The untrusted contract can re-enter the calling function and perform operations in an inconsistent state.
 
### 1.2 Vulnerable Code Example
```solidity
mapping(address => uint256) public balances;

function withdraw() public {
    uint256 amount = balances[msg.sender];
    require(amount > 0);

    (bool sent, ) = msg.sender.call{value: amount}("");
    require(sent, "Failed to send Ether");

    balances[msg.sender] = 0; // State update happens too late
}
```

### 1.3 Fix
Use the Checks-Effects-Interactions pattern:
```solidity
function withdraw() public {
    uint256 amount = balances[msg.sender];
    require(amount > 0);

    balances[msg.sender] = 0; // Update state before external call

    (bool sent, ) = msg.sender.call{value: amount}("");
    require(sent, "Failed to send Ether");
}
```
Alternatively, use `ReentrancyGuard` from OpenZeppelin:
```solidity
contract Vault is ReentrancyGuard {
    function withdraw() public nonReentrant {
        uint256 amount = balances[msg.sender];
        require(amount > 0);

        balances[msg.sender] = 0;
        (bool sent, ) = msg.sender.call{value: amount}("");
        require(sent, "Failed to send Ether");
    }
}
```

### 1.4 Real-World Hack
- [The DAO Hack (2016)](https://blog.chain.link/reentrancy-attacks-and-the-dao-hack/)
- [The Akropolis Hack(2021)](https://slowmist.medium.com/a-brief-analysis-of-the-akropolis-attack-7e979bd23831)

### 1.5 Learn More
- SWC Registry: [Kaysel: Reentrancy](https://www.kayssel.com/post/web3-4/)
- Solidity Docs: [Security Considerations](https://docs.soliditylang.org/en/latest/security-considerations.html#re-entrancy)

## 2. Unprotected `selfdestruct()`

### 2.1 What it is
When `selfdestruct()` is exposed without proper access control, any user can call it and destroy the contract, permanently removing code and balance.

### 2.2 Vulnerable Code Example
```solidity
function destroy() public {
    selfdestruct(payable(msg.sender)); // No access control
}
```

### 2.3 Fix
Add access control using `onlyOwner` or similar:
```solidity
address public owner;

constructor() {
    owner = msg.sender;
}

function destroy() public {
    require(msg.sender == owner, "Not authorized");
    selfdestruct(payable(owner));
}
```

### 2.4 Real-World Hack
- [Rubixi (DynamicPyramid) exploit](https://hackernoon.com/how-to-not-destroy-millions-in-smart-contracts-pt-2-85c4d8edd0cf)

### 2.5 Learn More
- SWC Registry: [SWC-106: Unprotected Selfdestruct](https://swcregistry.io/docs/SWC-106)

  ## 3. Incorrect State Transitions

### 3.1 What it is
Logic bugs that mishandle state updates, rewards, or conditions. Often subtle, leading to unfair behavior or bricking contracts.

### 3.2 Vulnerable Code Example

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IBadERC20 {
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
}

contract BrokenSubscription {
    IBadERC20 public token;
    mapping(address => uint256) public subscriptions;

    constructor(address tokenAddress) {
        token = IBadERC20(tokenAddress);
    }

    function subscribe(uint256 amount) external {
        // Business logic bug: ignoring transfer result
        token.transferFrom(msg.sender, address(this), amount);

        // State is updated even if transfer failed
        subscriptions[msg.sender] += amount;
    }
}
```

This contract updates internal state without confirming if the external token transfer actually succeeded. If the token’s `transferFrom()` silently fails (returns `false` without reverting), the contract still increases the `subscriptions` mapping — leading to a mismatch between payments and state.

### 3.3 Fix

Always check the return value of external calls, especially for tokens that may fail silently:

```solidity
function subscribe(uint256 amount) external {
    require(token.transferFrom(msg.sender, address(this), amount), "Transfer failed");

    subscriptions[msg.sender] += amount;
}
```

This fix ensures that the internal state is only updated if the token transfer succeeds. If the token call fails, the transaction reverts and no state is changed, maintaining consistency and security.


### 3.4 Real-World Hack
- [Cover Protocol exploit – logic flaw in claims](https://rekt.news/cover-rekt/)

### 3.5 Learn More
- [SWC Registry:](https://swcregistry.io/docs/SWC-135/)

## 4. Front-running Vulnerability

### 4.1 What it is
Attackers monitor mempool and front-run profitable transactions (e.g., buying before a user in DEX).

### 4.2 Vulnerable Code Example
```solidity
function placeBid(uint amount) public {
    require(amount > highestBid);
    highestBid = amount;
    winner = msg.sender;
}
```

### 4.3 Fix
Use commit-reveal or minimal slippage constraints:
```solidity
mapping(address => bytes32) public commits;

function commit(bytes32 hash) public {
    commits[msg.sender] = hash;
}

function reveal(uint value, string memory salt) public {
    require(keccak256(abi.encode(value, salt)) == commits[msg.sender], "Invalid reveal");

    // proceed to count bid or vote after revealing
}

```

### 4.4 Learn More
- [SWC-114: Front-running](https://swcregistry.io/docs/SWC-114)


## 5. Incorrect Precision Handling 
### 5.1 Truncation Errors

#### 5.1.1 What it is
Truncation occurs when Solidity performs integer division and silently rounds down any decimal result. Since Solidity does not support floating-point numbers, calculations like percentages, ratios, or shares must be carefully scaled to avoid precision loss or unintended behavior.

A common mistake is using raw integer division without fixed-point scaling, especially in share accounting like:

```solidity
userShare = assetsDeposited / totalAssets;
```
This truncates anything below 1, meaning small depositors may get 0 shares even if they deposited something non-zero.

#### 5.1.2 Vulnerable Code Example
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Vault {
    uint256 public totalAssets;
    uint256 public totalShares;
    mapping(address => uint256) public shares;

    function deposit(uint256 amount) external {
        uint256 share;

        if (totalAssets == 0 || totalShares == 0) {
            // First depositor gets 1:1 shares
            share = amount;
        } else {
            // Vulnerable: truncation occurs here
            share = (amount * totalShares) / totalAssets;
        }

        require(share > 0, "Truncated to zero shares"); // Will fail for small deposits
        shares[msg.sender] += share;

        totalAssets += amount;
        totalShares += share;
    }
}
```

What’s wrong?
If `amount * totalShares < totalAssets`, then the result rounds down to zero.

Small deposits get no shares, and their funds are essentially donated to the pool.

#### 5.1.3 Fix
Use a fixed-point math library like `PRBMath` or `WadRayMath`, or apply consistent scaling using 1e18 to preserve precision.

Safe version using `PRBMath`:
```solidity
import { ud, UD60x18 } from "@prb/math/UD60x18.sol";

function deposit(uint256 amount) external {
    uint256 share;

    if (totalAssets == 0 || totalShares == 0) {
        share = amount;
    } else {
        UD60x18 amt = ud(amount);
        UD60x18 ts = ud(totalShares);
        UD60x18 ta = ud(totalAssets);
        share = amt.mul(ts).div(ta).unwrap(); // High-precision math
    }

    require(share > 0, "No shares minted");
    shares[msg.sender] += share;
    totalAssets += amount;
    totalShares += share;
}
```
### 5.2 Incorrect token decimal handling
#### 5.2.1 What it is
Tokens have varying decimal values (e.g., USDT: 6, ETH: 18). Misunderstanding this causes incorrect math or transfers.

#### 5.2.2 Fix
Normalize based on token decimals:
```solidity
uint8 decimals = IERC20Metadata(usdt).decimals();
uint amount = 10 ** uint(decimals); // 1 USDT
```
e.g
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";

contract TokenSender {
    function transferToken(address token, address to, uint amountWholeTokens) external {
        uint8 decimals = IERC20Metadata(token).decimals();
        uint scaledAmount = amountWholeTokens * (10 ** uint(decimals));

        require(IERC20(token).transfer(to, scaledAmount), "Transfer failed");
    }
}
```

### 5.5 Learn More
- [PRBMath – Resource Guide](https://github.com/PaulRBerg/prb-math)
- [OpenZeppelin ERC20 Metadata](https://docs.openzeppelin.com/contracts/5.x/api/token/erc20#IERC20Metadata)
## 6. Initialization of Proxy Contracts

### 6.1 What it is
In upgradeable contracts, the logic contract must be initialized securely. If not, attackers can initialize it themselves and take over ownership.

### 6.2 Vulnerable Code Example
```solidity
contract Logic {
    address public owner;

    function initialize() public {
        owner = msg.sender;
    }
}
```

### 6.3 Fix
Use `initializer` modifier and lock initialization:
```solidity
contract Logic is Initializable {
    address public owner;

    function initialize() public initializer {
        owner = msg.sender;
    }

    constructor() {
        _disableInitializers();
    }
}
```

### 6.4 Real-World Hack
- [Audius governance takeover](https://rekt.news/audius-rekt/)

### 6.5 Learn More
- OpenZeppelin Docs: [Proxy Upgrade Patterns](https://docs.openzeppelin.com/upgrades-plugins/1.x/proxies)

## 7. Missing `onlyOwner` / Access Control

### 7.1 What it is
Critical functions such as `mint()`, `pause()`, or `upgrade()` should not be accessible to everyone. Omitting access control allows anyone to call them.

### 7.2 Vulnerable Code Example
```solidity
function mint(address to, uint256 amount) public {
    _mint(to, amount); // No access control
}
```

### 7.3 Fix
Add ownership checks:
```solidity
address public owner;

modifier onlyOwner() {
    require(msg.sender == owner, "Not owner");
    _;
}

function mint(address to, uint256 amount) public onlyOwner {
    _mint(to, amount);
}
```

### 7.4 Learn More
- SWC Registry: [SWC-105: Unprotected Function](https://swcregistry.io/docs/SWC-105)

## 8. Role Escalation

### 8.1 What it is
Improper setup of `AccessControl` can allow users with the admin role to escalate their own privileges and assign themselves elevated roles.

### 8.2 Vulnerable Code Example
```solidity
grantRole(DEFAULT_ADMIN_ROLE, msg.sender); // Grants all permissions
```

### 8.3 Fix
Add Access Control checks:
```solidity
grantRole(DEFAULT_ADMIN_ROLE, msg.sender) public override{
require(msg.sender == owner, "ERROR!"); // Grants all permissions
}
```

### 8.4 Learn More
- OpenZeppelin Docs: [AccessControl](https://docs.openzeppelin.com/contracts/4.x/access-control)

## 9. Unbounded Loops

### 9.1 What it is
Loops that iterate over dynamic storage arrays can exceed the block gas limit, making the function uncallable.

### 9.2 Vulnerable Code Example
```solidity
address[] public users;

function distribute() public {
    for (uint i = 0; i < users.length; i++) {
        payable(users[i]).transfer(1 ether);
    }
}
```

### 9.3 Fix
Avoid unbounded iteration. Use pull payments:
```solidity
mapping(address => uint256) public payouts;

function claim() public {
    uint256 amount = payouts[msg.sender];
    require(amount > 0);
    payouts[msg.sender] = 0;
    payable(msg.sender).transfer(amount);
}
```

### 9.4 Learn More
- [SWC-128: DoS with Block Gas Limit](https://swcregistry.io/docs/SWC-128)

## 10. Griefing via DoS

### 10.1 What it is
A malicious user can sabotage contract behavior (e.g., block withdrawals) by deliberately causing failure in shared flows.

### 10.2 Vulnerable Code Example
```solidity
function payoutAll() public {
    for (uint i = 0; i < users.length; i++) {
        users[i].call{value: 1 ether}("");
    }
}
```

### 10.3 Fix
Use pull-based architecture:
```solidity
function withdraw() public {
    uint256 amount = payouts[msg.sender];
    require(amount > 0);
    payouts[msg.sender] = 0;
    payable(msg.sender).transfer(amount);
}
```

### 10.4 Learn More
- [SWC-113: DoS by Griefing](https://swcregistry.io/docs/SWC-113)

